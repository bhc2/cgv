<!DOCTYPE html>
<html>
    <head>
        <title>Programs</title>
    </head>
    <body>
        <strong>Cube Spin (3rd Program) </strong>
        <pre>
#include&ltstdlib.h>
#include&ltGL/glut.h>
GLfloat vertices[][3] = {{-1.0,-1.0,-1.0},{1.0,-1.0,-1.0}, {1.0,1.0,-1.0}, {-1.0,1.0,-1.0}, 
                {-1.0,-1.0,1.0}, {1.0,-1.0,1.0}, {1.0,1.0,1.0}, {-1.0,1.0,1.0}};
GLfloat normals[][3] = {{-1.0,-1.0,-1.0},{1.0,-1.0,-1.0}, {1.0,1.0,-1.0}, {-1.0,1.0,-1.0}, 
                {-1.0,-1.0,1.0}, {1.0,-1.0,1.0}, {1.0,1.0,1.0}, {-1.0,1.0,1.0}};
GLfloat colors[][3] = {{0.0,0.0,0.0},{1.0,0.0,0.0}, {1.0,1.0,0.0}, {0.0,1.0,0.0},{0.0,0.0,1.0}, {1.0,0.0,1.0}, {1.0,1.0,1.0}, {0.0,1.0,1.0}};

void  polygon(int a, int b, int c , int d)
{
/* draw a polygon via list of vertices */
glBegin(GL_POLYGON);
glColor3fv(colors[a]);
glNormal3fv(normals[a]);
glVertex3fv(vertices[a]);
glColor3fv(colors[b]);
glNormal3fv(normals[b]);
glVertex3fv(vertices[b]);
glColor3fv(colors[c]);
glNormal3fv(normals[c]);
glVertex3fv(vertices[c]);
glColor3fv(colors[d]);
glNormal3fv(normals[d]);
glVertex3fv(vertices[d]);
glEnd();
}
void  colorcube(void)
{
/* map vertices to faces */
polygon(0,3,2,1);
polygon(2,3,7,6);
polygon(0,4,7,3);
polygon(1,2,6,5);
polygon(4,5,6,7);
polygon(0,1,5,4);
}
static GLfloat theta[] = {0.0,0.0,0.0};
static GLint axis = 2;

void  display(void)
{
/* display callback, clear frame buffer and z buffer,
rotate cube and draw, swap buffers */
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
glLoadIdentity();
glRotatef(theta[0], 1.0, 0.0, 0.0);
glRotatef(theta[1], 0.0, 1.0, 0.0);
glRotatef(theta[2], 0.0, 0.0, 1.0);
colorcube();
glFlush();
glutSwapBuffers();
}

void  spinCube()
{
/* Idle callback, spin cube 2 degrees about selected axis */
theta[axis] += 1.0;
if( theta[axis] > 360.0 ) theta[axis] -= 360.0;
/* display(); */
glutPostRedisplay();
}

void  mouse(int btn, int state, int x, int y)
{
/* mouse callback, selects an axis about which to rotate */
if(btn==GLUT_LEFT_BUTTON && state == GLUT_DOWN) axis = 0;
if(btn==GLUT_MIDDLE_BUTTON && state == GLUT_DOWN) axis = 1;
if(btn==GLUT_RIGHT_BUTTON && state == GLUT_DOWN) axis = 2;
}
void  myReshape(int w, int h)
{
glViewport(0, 0, w, h);
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
if (w <= h)
glOrtho(-2.0, 2.0, -2.0 * (GLfloat) h / (GLfloat) w, 2.0 * (GLfloat) h / (GLfloat) w, -10.0, 10.0);
else
glOrtho(-2.0 * (GLfloat) w / (GLfloat) h, 2.0 * (GLfloat) w / (GLfloat) h, -2.0, 2.0, -10.0, 10.0);
glMatrixMode(GL_MODELVIEW);
}

void  main(int argc, char **argv)
{
 glutInit(&argc, argv);
/* need both double buffering and z buffer */
glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
glutInitWindowSize(500, 500);
glutCreateWindow("Rotating a Color Cube");
glutReshapeFunc(myReshape);
glutDisplayFunc(display);
glutIdleFunc(spinCube);
glutMouseFunc(mouse);
glEnable(GL_DEPTH_TEST); /* Enable hidden--surface--removal */
glutMainLoop();
}

        </pre>
<br>
<br>
<strong>Perspective viewing (4th Program)</strong>
<pre>
#include&ltstdlib.h>
#include&ltGL/glut.h>
GLfloat vertices[][3] = {{-1.0,-1.0,-1.0},{1.0,-1.0,-1.0}, {1.0,1.0,-1.0}, {-1.0,1.0,-1.0}, 
                {-1.0,-1.0,1.0}, {1.0,-1.0,1.0}, {1.0,1.0,1.0}, {-1.0,1.0,1.0}};
GLfloat normals[][3] = {{-1.0,-1.0,-1.0},{1.0,-1.0,-1.0}, {1.0,1.0,-1.0}, {-1.0,1.0,-1.0}, 
                {-1.0,-1.0,1.0}, {1.0,-1.0,1.0}, {1.0,1.0,1.0}, {-1.0,1.0,1.0}};
GLfloat colors[][3] = {{0.0,0.0,0.0},{1.0,0.0,0.0}, {1.0,1.0,0.0}, {0.0,1.0,0.0}, {0.0,0.0,1.0},
            {1.0,0.0,1.0}, {1.0,1.0,1.0}, {0.0,1.0,1.0}};

void  polygon(int a, int b, int c , int d)
{
glBegin(GL_POLYGON);
glColor3fv(colors[a]);
glNormal3fv(normals[a]);
glVertex3fv(vertices[a]);
glColor3fv(colors[b]);
glNormal3fv(normals[b]);
glVertex3fv(vertices[b]);
glColor3fv(colors[c]);
glNormal3fv(normals[c]);
glVertex3fv(vertices[c]);
glColor3fv(colors[d]);
glNormal3fv(normals[d]);
glVertex3fv(vertices[d]);
glEnd();
}
void colorcube()
{
polygon(0,3,2,1);
polygon(2,3,7,6);
polygon(0,4,7,3);
polygon(1,2,6,5);
polygon(4,5,6,7);
polygon(0,1,5,4);
}

static GLfloat theta[] = {0.0,0.0,0.0};
static GLint axis = 2;
static GLdouble viewer[]= {0.0, 0.0, 5.0}; /* initial viewer location */

void display(void)
{
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
/* Update viewer position in modelview matrix */
glLoadIdentity();
gluLookAt(viewer[0],viewer[1],viewer[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
/* rotate cube */
glRotatef(theta[0], 1.0, 0.0, 0.0);
glRotatef(theta[1], 0.0, 1.0, 0.0);
glRotatef(theta[2], 0.0, 0.0, 1.0);
colorcube();
glFlush();
glutSwapBuffers();
}

void mouse(int btn, int state, int x, int y)
{
if(btn==GLUT_LEFT_BUTTON && state == GLUT_DOWN) axis = 0;
if(btn==GLUT_MIDDLE_BUTTON && state == GLUT_DOWN) axis = 1;
if(btn==GLUT_RIGHT_BUTTON && state == GLUT_DOWN) axis = 2;
theta[axis] += 2.0;
if( theta[axis] > 360.0 ) theta[axis] -= 360.0;
display();
}

void keys(unsigned char key, int x, int y)
{
/* Use x, X, y, Y, z, and Z keys to move viewer */
if(key == 'x') viewer[0]-= 1.0;
if(key == 'X') viewer[0]+= 1.0;
if(key == 'y') viewer[1]-= 1.0;
if(key == 'Y') viewer[1]+= 1.0;
if(key == 'z') viewer[2]-= 1.0;
if(key == 'Z') viewer[2]+= 1.0;
display();
}

void myReshape(int w, int h)
{
glViewport(0, 0, w, h);
/* Use a perspective view */
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
if(w<=h)
glFrustum(-2.0, 2.0, -2.0*(GLfloat) h/(GLfloat) w,2.0* (GLfloat) h / (GLfloat) w,2.0, 20.0);
else 
glFrustum(-2.0, 2.0, -2.0*(GLfloat) w/(GLfloat) h,2.0* (GLfloat) w/(GLfloat) h, 2.0, 20.0);
/* Or we can use gluPerspective */
/* gluPerspective(45.0, w/h, -10.0, 10.0); */
glMatrixMode(GL_MODELVIEW);
}

void main(int argc, char **argv)
{
glutInit(&argc, argv);
glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
glutInitWindowSize(500, 500);
glutCreateWindow("Colorcube Viewer");
glutReshapeFunc(myReshape);
glutDisplayFunc(display);
glutMouseFunc(mouse);
glutKeyboardFunc(keys);
glEnable(GL_DEPTH_TEST);
glutMainLoop();
}        
</pre>
<br>
<br>
        
             <strong> 7th Program</strong>
                <pre>
                        #include&ltstdio.h> 
                        #include&ltstdlib.h>
                        
                        int no;
                        void roundrobin(int,int,int[],int[]);
                        void srtf();
                        main()
                        {
                            int n,tq,choice;
                            int bt[10], st[10], i,j,k;
                            for(;;)
                            {
                                printf("Enter choice\n");
                                printf("1.Round Robin \n2.str \n3.Exit\n");
                                scanf("%d",&choice);
                                switch(choice)
                                {
                                    case 1: printf("Round robin scheduling algorithm\n");
                                        printf("Enter the number of process\n");
                                        scanf("%d",&n);
                                        printf("Enter burst time for sequences\n");
                                        for(i=0;i < n ; i++)

                                        {
                                             scanf("%d" ,&bt[i]);
                                            st[i]=bt[i];
                                        }
                                        
                                        printf("Enter time quantum\n");
                                        scanf("%d",&tq);
                                        roundrobin(n,tq,st,bt);
                                        break;
                                    case 2: printf("\n\n-------------------Shortest remaining time------\n\n");
                                            printf("\n");
                                        srtf();
                                        break;
                                    case 3: exit(0);
                                        break;
                                }
                            }
                        }
                            
                        void roundrobin(int n, int tq, int st[], int bt[])
                        {
                            int time=0;
                            int tat[10],wt[10],i,count=0,swt=0,stat=0,temp1,sq=0,j,k;
                            float awt=0.0, atat=0.0; 
                            while(1)
                            {
                        for(i=0,count=0;i< n;i++)
                                {
                                    temp1=tq;
                                    if(st[i]==0)
                                    {
                                        count++;
                                        continue;
                                    }
                                    if (st[i]>tq)
                                        st[i]=st[i]-tq;
                                    else if(st[i]>=0)
                                    {
                                        temp1=st[i];
                                        st[i]=0;
                                    }
                                    sq=sq+temp1;
                                    tat[i]=sq;
                                }
                                if(n==count)
                                break;
                            }
                            for(i=0;i< n;i++)
                            {
                                wt[i]=tat[i]-bt[i];
                                swt=swt+wt[i];
                                stat=stat+tat[i];
                            }
                            awt=(float)swt/n;
                            atat=(float)stat/n;
                            printf("process no   burst time  waiting time 	turnaround time\n");
                            for(i=0;i< n;i++)
                                printf("%d \t\t %d \t\t %d \t\t %d \t\t\n",i+1,bt[i],wt[i],tat[i]);
                            printf("average waiting time is%f\n avg turnaround time is %f\n",awt,atat);
                            
                        }
                        
                        void srtf()
                        {
                            int n,j=0,st[10],bt[10],rt[10],remain=0,smallest,time=0,i,endtime,swt=0,stat=0;
                            printf("enter the no. of process:");
                            scanf("%d",&n);
                            for(i=0;i< n;i++)
                            {
                                printf("enter the arrivaltime for p[%d]:",i+1);
                                scanf("%d",&st[i]);
                                printf("enter the burst time for p[%d]:",i+1);
                                scanf("%d",&bt[i]);
                                rt[i]=bt[i];
                            }
                            rt[100]=999;
                        printf("process\t|writing time\t|turnarround time\n");
                            for(time=0;remain!=n;time++)
                             {
                                 smallest=100;
                                 for(i=0;i< n;i++)
                                {
                                    if(st[i]<=time && rt[i]< rt[smallest] && rt[i]>0)
                                    {
                                        smallest=i;
                                    }
                                }
                                rt[smallest]--;
                                if(rt[smallest]==0)
                                {
                                    remain++;
                                    endtime=time+1;
                                    j=smallest;
                                    printf("p[%d]\t|\t%d\t|\t%d\n",smallest+1,endtime-bt[j]-st[j],endtime-st[j]);
                                    swt +=endtime-bt[j]-st[j];
                                    stat +=endtime-st[j];
                                }
                            }
                            float awt=0.0,atat=0.0;
                            awt=(float)swt/n;
                            atat=(float)stat/n;
                            printf("average waiting time:%f\n",awt);
                            printf("average turnarround time:%f\n",atat);
                        }
                        
                        
                </pre>
           

            
            </body>
</html>
